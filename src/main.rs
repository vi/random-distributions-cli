use rand::SeedableRng;
use std::io::Write;
use std::f64::consts::FRAC_PI_2;
use std::f64::consts::FRAC_2_PI;


/// Command-line tool to generate samples of various random distributions
#[derive(argh::FromArgs)]
struct Opts {
    /// number of digits after decimal to print
    #[argh(option,default="10",short='p')]
    precision: usize,

    /// add value of each sample to buffer
    #[argh(switch,short='C')]
    cumulative: bool,

    /// use specified seed instead for PRNG
    #[argh(option,short='S')]
    seed: Option<u64>,

    #[argh(subcommand)]
    distribution : Distributions,
}

#[derive(argh::FromArgs)]
#[argh(subcommand)]
enum Distributions {
    Uniform(Uniform),
    Normal(Normal),
    Cauchy(Cauchy),
    Triangular(Triangular),
    StudentsT(StudentsT),
    Stable(Stable),
}

trait DistributionObject {
    fn sample(&self, rng: &mut rand::rngs::SmallRng) -> f64;
}
impl<T: rand::distributions::Distribution<f64>> DistributionObject for T {
    fn sample(&self, rng: &mut rand::rngs::SmallRng) -> f64 {
        rand::distributions::Distribution::sample(self, rng)
    }
}

/// Uniform distribution
#[derive(argh::FromArgs)]
#[argh(subcommand, name="uniform")]
struct Uniform {
    /// include specified maximum value as possible candidate for generation
    #[argh(switch)]
    right_inclusive: bool,

    #[argh(positional)]
    min: f64,

    #[argh(positional)]
    max: f64,
}

/// Normal, Gaussian distribution
#[derive(argh::FromArgs)]
#[argh(subcommand, name="normal")]
struct Normal {
    #[argh(positional)]
    mean: f64,

    #[argh(positional)]
    std_dev: f64,
}

/// Cauchy, Lorentz distribution - fat-tailed and continuous
#[derive(argh::FromArgs)]
#[argh(subcommand, name="cauchy")]
struct Cauchy {
    #[argh(positional)]
    location: f64,

    #[argh(positional)]
    scale: f64,
}


/// Triangular distribution - continuous
#[derive(argh::FromArgs)]
#[argh(subcommand, name="triangular")]
struct Triangular {
    #[argh(positional)]
    min: f64,


    #[argh(positional)]
    mode: f64,

    #[argh(positional)]
    max: f64,
}


/// Student-T distribution
#[derive(argh::FromArgs)]
#[argh(subcommand, name="studentt")]
struct StudentsT {
    #[argh(positional)]
    location: f64,


    #[argh(positional)]
    scale: f64,

    #[argh(positional)]
    freedom: f64,
}

/// General case of stable continuous distribution, generated by CMS method
#[derive(argh::FromArgs)]
#[argh(subcommand, name="stable")]
struct Stable {
    #[argh(positional)]
    location: f64,


    #[argh(positional)]
    scale: f64,

    #[argh(positional)]
    alpha: f64,

    #[argh(positional)]
    beta: f64,
}

struct StableAlphaNotOne {
    location: f64,
    alpha: f64,
    u_dist: rand::distributions::Uniform<f64>,
    w_dist: statrs::distribution::Exp,
    calc_scale: f64,
    xi: f64,
    alpha_inv: f64,
    alpha2: f64,
}

impl StableAlphaNotOne {
    pub fn new(location: f64, mut scale: f64, alpha: f64, beta: f64) -> Self {
        scale /= alpha.sqrt();  // I don't know why is this needed, but without this it does not match both Cauchy and Normal distributions
        let zeta = -beta * (FRAC_PI_2*alpha).tan();
        Self {
            location,
            alpha,
            u_dist: rand::distributions::Uniform::new(-FRAC_PI_2 + 3.0*f64::EPSILON, FRAC_PI_2 ),
            w_dist: statrs::distribution::Exp::new(1.0).unwrap(),
            calc_scale: (zeta*zeta+1.0).powf(0.5/alpha)*scale,
            xi: (-zeta).atan() / alpha,
            alpha_inv: 1.0/alpha,
            alpha2: (1.0 - alpha)/alpha,
        }
    }
}

/// Implementation is based on https://en.wikipedia.org/w/index.php?title=Stable_distribution&oldid=1025369901
impl DistributionObject for StableAlphaNotOne {
    fn sample(&self, rng: &mut rand::rngs::SmallRng) -> f64 {
        let u = self.u_dist.sample(rng);
        let w = self.w_dist.sample(rng);
        let num1 = (self.alpha*(u + self.xi)).sin();
        let den1 = u.cos().powf(self.alpha_inv);
        let num2 = (u - self.alpha * (u + self.xi)).cos() / w;
        self.location + self.calc_scale * num1 / den1 * (num2).powf(self.alpha2)
    }
}

struct StableAlphaOne {
    location: f64,
    beta: f64,
    u_dist: rand::distributions::Uniform<f64>,
    w_dist: statrs::distribution::Exp,
    calc_scale: f64,
}

impl StableAlphaOne {
    pub fn new(location: f64, scale: f64, beta: f64) -> Self {
        //scale *= std::f64::consts::FRAC_1_SQRT_2;
        Self {
            location: location + FRAC_2_PI * beta * scale * scale.ln(),
            beta,
            u_dist: rand::distributions::Uniform::new(-FRAC_PI_2 + 3.0*f64::EPSILON, FRAC_PI_2 ),
            w_dist: statrs::distribution::Exp::new(1.0).unwrap(),
            calc_scale: scale * FRAC_2_PI,
        }
    }
}

/// Implementation is based on https://en.wikipedia.org/w/index.php?title=Stable_distribution&oldid=1025369901
impl DistributionObject for StableAlphaOne {
    fn sample(&self, rng: &mut rand::rngs::SmallRng) -> f64 {
        let u = self.u_dist.sample(rng);
        let w = self.w_dist.sample(rng);
        self.location + self.calc_scale * ( (FRAC_PI_2 + self.beta * u) * u.tan() - self.beta * ( (FRAC_PI_2 * w * u.cos())/(FRAC_PI_2 + self.beta*u) ).ln() )
    }
}


fn main() -> anyhow::Result<()> {
    let opts : Opts = argh::from_env();

    let so = std::io::stdout();
    let so = so.lock();
    let mut so = std::io::BufWriter::with_capacity(32768, so);

    let d : Box<dyn DistributionObject>;
    d = match opts.distribution {
        Distributions::Uniform(Uniform { right_inclusive, min, max }) => {
            if max <= min {
                anyhow::bail!("Invalid distribution parameters");
            }
            if right_inclusive {
                Box::new(rand::distributions::Uniform::new_inclusive(min, max))
            } else {
                Box::new(rand::distributions::Uniform::new(min, max))
            }
        }
        Distributions::Normal(Normal { mean, std_dev }) => Box::new(statrs::distribution::Normal::new(mean, std_dev)?),
        Distributions::Cauchy(Cauchy { location, scale }) => Box::new(statrs::distribution::Cauchy::new(location, scale)?),
        Distributions::Triangular(Triangular { min, mode, max }) => Box::new(statrs::distribution::Triangular::new(min,max,mode)?),
        Distributions::StudentsT(StudentsT { location, scale, freedom }) =>  Box::new(statrs::distribution::StudentsT::new(location,scale,freedom)?),
        Distributions::Stable(Stable { location, scale, alpha, beta }) => {
            if alpha < 0.0 || alpha > 2.0 {
                anyhow::bail!("alpha must be between 0 and 2");
            }
            if beta < -1.0 || beta > 1.0 {
                anyhow::bail!("beta must be between -1 and 1");
            }
            if alpha > 0.999 && alpha < 1.001 {
                Box::new(StableAlphaOne::new(location,scale,beta))
            } else {
                Box::new(StableAlphaNotOne::new(location,scale,alpha,beta))
            }
        }
    };
    
    let mut r = if let Some(s) = opts.seed {
        rand::rngs::SmallRng::seed_from_u64(s)
    } else {
        rand::rngs::SmallRng::from_entropy()
    };

    let mut c : f64 = 0.0;
    loop {
        let x = d.sample(&mut r);
        if opts.cumulative {
            c += x;
            writeln!(so, "{:.*}", opts.precision, c)?;
        } else {
            writeln!(so, "{:.*}", opts.precision, x)?;
        }
    }
}
